* Write a manual of assumption we make about the videos in order to track everything
* Distinguish between debug/develop/release runs:
	- different default level of output
	- debug doesn't use multiprocessing to keep error messages clean
	- different logging behavior (log to file for release run!)
	- different error behavior (use some catch all try/except and log the error instead of failing in release run)
	- this could be implemented via helper functions in mousetracking.simple that configure python + parameters
* Determine absolute times by checking when the lights go on
	- this does only seem to be visible outside the cage
* Get precise cage dimensions:
	- Do line scans at border in all directions and determine cage edge
	- Think about getting a more precise estimate of the cage
* Gather more statistics about why certain parts of the algorithm failed
* Distinguish mouse position at burrow apex from positions at other points in burrow
	- Analyze excavated burrow space (after mouse has been active)
* Third pass burrow finding:
	If mouse is in burrow, burrow shape could be the union of grab cut (with mouse present)
	and the explored area
	Burrow finding of first pass can be removed altogether (if third pass gets sufficiently nice results)


Performance improvements:
-------------------------
* Make sure that images and masks are not copied to often (rather use internal cache structures, which should be faster)
	- Do operations in place as often as possible
* Generally cache all kernels for morphological operations, since these are costly to make
* Performance is limited by reading the video using ffmpeg (which is capped at about 50 fps)


Low priority enhancements:
--------------------------