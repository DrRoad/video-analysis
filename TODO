* Write a manual of assumption we make about the videos in order to track everything
* Distinguish between debug/develop/release runs:
	- different default level of output
	- debug doesn't use multiprocessing to keep error messages clean
	- different logging behavior (log to file for release run!)
	- different error behavior (use some catch all try/except and log the error instead of failing in release run)
	- this could be implemented via helper functions in mousetracking.simple that configure python + parameters
* Determine absolute times by checking when the lights go on
	- this does only seem to be visible outside the cage
* Gather more statistics about why certain parts of the algorithm failed
* Distinguish mouse position at burrow apex from positions at other points in burrow
	- Analyze excavated burrow space (after mouse has been active)
* First pass might want to construct a binary image of all the area that was explored by any moving object
	- This mask could be saved in the hdf file and than used later to restrict the mouse movement
* Refine the centerline by moving the points more toward the actual center
	- this could be done by segmenting the current centerline in equally spaced segments
	- each inner point on this center line can be put at the midpoint between the outlines
		to prevent problems, the point should be displaced by at most 0.5*burrow_width
	- Alternatively, find centerline by using active snake guided by current centerline and distance map
* Use images of final burrow cast to locate burrows (by analyzing the video in reverse)
* Think about method to remove the water bottle
	- keep an image of the water bottle (similar to how we get an image of the background)
	- subtract that image from the frame, but add back its median
	=> this should remove the water bottle, but keep fluctuations
		this might cause troubles if the mouse stays too long in the region,
		although this should typically not be the case 
* Add code to automatically restart analysis if ffmpeg error occurred
	- implement `process` function in data_handler, which repeatedly calls a `process_video` function until no ffmpeg error occurs
	- the `process_video` function contains the code which is currently in the `process` functions
* Pass4:
	- connect two burrows that face each other (which happens for burrows with two exits) 
  	

Performance improvements:
-------------------------
* Make sure that images and masks are not copied to often (rather use internal cache structures, which should be faster)
	- Do operations in place as often as possible
* Generally cache all kernels for morphological operations, since these are costly to make
* Performance is limited by reading the video using ffmpeg (which is capped at about 50 fps)


Low priority enhancements:
--------------------------