* Write a manual of assumption we make about the videos in order to track everything
* Distinguish between debug/develop/release runs:
	- different default level of output
	- debug doesn't use multiprocessing to keep error messages clean
	- different logging behavior (log to file for release run!)
	- different error behavior (use some catch all try/except and log the error instead of failing in release run)
	- this could be implemented via helper functions in mousetracking.simple that configure python + parameters
* Determine absolute times by checking when the lights go on
	- this does only seem to be visible outside the cage
* Gather more statistics about why certain parts of the algorithm failed
* Distinguish mouse position at burrow apex from positions at other points in burrow
	- Analyze excavated burrow space (after mouse has been active)
* First pass might want to construct a binary image of all the area that was explored by any moving object
	- This mask could be saved in the hdf file and than used later to restrict the mouse movement
* Refine the centerline by moving the points more toward the actual center
	- this could be done by segmenting the current centerline in equally spaced segments
	- each inner point on this center line can be put at the midpoint between the outlines
		to prevent problems, the point should be displaced by at most 0.5*burrow_width
	- Alternatively, find centerline by using active snake guided by current centerline and distance map
* Use images of final burrow cast to locate burrows (by analyzing the video in reverse)
* Pass2:
	- break graph based tracking into multiple steps separated by tracks where we are sure that they belong to a mouse
		These are long tracks where we detect enough movement.
		This should both speed up the tracking and more importantly reduce memory footprint
* Pass3:
    - mouse trail processing:
        - intersect mouse trail with ground polygon to adapt it to moving ground
        - if mouse trail gets cut into two parts, keep the longer part (and check its orientation!)
* Pass4:
	- connect two burrows that face each other (which happens for burrows with two exits) 
* Move 'get_code_status' into the __init__ file of the tracking program, which will produce
    more accurate results for code which restarts tracking frequently 
 

Performance improvements:
-------------------------
* Make sure that images and masks are not copied to often (rather use internal cache structures, which should be faster)
	- Do operations in place as often as possible
* Generally cache all kernels for morphological operations, since these are costly to make
* Performance is limited by reading the video using ffmpeg (which is capped at about 50 fps)


Low priority enhancements:
--------------------------